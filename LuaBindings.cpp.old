//
// LuaBindings.cpp
// LuaRunner2 - Lua bindings for SuperTerminal API
//
// This file provides Lua bindings for all SuperTerminal C API functions.
// Functions are registered in the global Lua namespace.
//

#include "LuaBindings.h"
#include "API/superterminal_api.h"
#include "../Framework/Particles/ParticleSystem.h"
#include <lua.hpp>
#include <string>
#include <cstring>

using SuperTerminal::ParticleMode;

namespace SuperTerminal {
namespace LuaBindings {

// =============================================================================
// Helper Functions
// =============================================================================

static void luaL_setglobalfunction(lua_State* L, const char* name, lua_CFunction func) {
    lua_pushcfunction(L, func);
    lua_setglobal(L, name);
}

static void luaL_setglobalnumber(lua_State* L, const char* name, lua_Number value) {
    lua_pushnumber(L, value);
    lua_setglobal(L, name);
}

// =============================================================================
// Text API Bindings
// =============================================================================

static int lua_st_text_putchar(lua_State* L) {
    int x = luaL_checkinteger(L, 1);
    int y = luaL_checkinteger(L, 2);
    const char* str = luaL_checkstring(L, 3);
    uint32_t fg = luaL_optinteger(L, 4, 0xFFFFFFFF);
    uint32_t bg = luaL_optinteger(L, 5, 0xFF000000);
    
    if (str && str[0]) {
        st_text_putchar(x, y, str[0], fg, bg);
    }
    return 0;
}

// poke_text: directly write a 32-bit character code to text grid
static int lua_poke_text(lua_State* L) {
    int x = luaL_checkinteger(L, 1);
    int y = luaL_checkinteger(L, 2);
    uint32_t character = luaL_checkinteger(L, 3);
    uint32_t fg = luaL_optinteger(L, 4, 0xFFFFFFFF);
    uint32_t bg = luaL_optinteger(L, 5, 0xFF000000);
    
    st_text_putchar(x, y, character, fg, bg);
    return 0;
}

static int lua_st_text_put(lua_State* L) {
    int x = luaL_checkinteger(L, 1);
    int y = luaL_checkinteger(L, 2);
    const char* text = luaL_checkstring(L, 3);
    uint32_t fg = luaL_optinteger(L, 4, 0xFFFFFFFF);
    uint32_t bg = luaL_optinteger(L, 5, 0xFF000000);
    
    st_text_put(x, y, text, fg, bg);
    return 0;
}

static int lua_st_text_clear(lua_State* L) {
    (void)L;
    st_text_clear();
    return 0;
}

static int lua_st_text_clear_region(lua_State* L) {
    int x = luaL_checkinteger(L, 1);
    int y = luaL_checkinteger(L, 2);
    int width = luaL_checkinteger(L, 3);
    int height = luaL_checkinteger(L, 4);
    
    st_text_clear_region(x, y, width, height);
    return 0;
}

static int lua_st_text_set_size(lua_State* L) {
    int width = luaL_checkinteger(L, 1);
    int height = luaL_checkinteger(L, 2);
    
    st_text_set_size(width, height);
    return 0;
}

static int lua_st_text_get_size(lua_State* L) {
    int width, height;
    st_text_get_size(&width, &height);
    
    lua_pushinteger(L, width);
    lua_pushinteger(L, height);
    return 2;
}

static int lua_st_text_scroll(lua_State* L) {
    int lines = luaL_checkinteger(L, 1);
    st_text_scroll(lines);
    return 0;
}

// =============================================================================
// Sixel Graphics API Bindings
// =============================================================================

static int lua_st_text_putsixel(lua_State* L) {
    int x = luaL_checkinteger(L, 1);
    int y = luaL_checkinteger(L, 2);
    uint32_t sixel_char = luaL_checkinteger(L, 3);
    uint32_t bg = luaL_optinteger(L, 5, 0xFF000000);
    
    // Get the colors table (6 elements)
    luaL_checktype(L, 4, LUA_TTABLE);
    uint8_t colors[6];
    for (int i = 0; i < 6; i++) {
        lua_rawgeti(L, 4, i + 1); // Lua arrays are 1-indexed
        colors[i] = (uint8_t)luaL_checkinteger(L, -1);
        lua_pop(L, 1);
    }
    
    st_text_putsixel(x, y, sixel_char, colors, bg);
    return 0;
}

static int lua_st_sixel_pack_colors(lua_State* L) {
    // Get the colors table (6 elements)
    luaL_checktype(L, 1, LUA_TTABLE);
    uint8_t colors[6];
    for (int i = 0; i < 6; i++) {
        lua_rawgeti(L, 1, i + 1); // Lua arrays are 1-indexed
        colors[i] = (uint8_t)luaL_checkinteger(L, -1);
        lua_pop(L, 1);
    }
    
    uint32_t packed = st_sixel_pack_colors(colors);
    lua_pushinteger(L, packed);
    return 1;
}

static int lua_st_text_putsixel_packed(lua_State* L) {
    int x = luaL_checkinteger(L, 1);
    int y = luaL_checkinteger(L, 2);
    uint32_t sixel_char = luaL_checkinteger(L, 3);
    uint32_t packed_colors = luaL_checkinteger(L, 4);
    uint32_t bg = luaL_optinteger(L, 5, 0xFF000000);
    
    st_text_putsixel_packed(x, y, sixel_char, packed_colors, bg);
    return 0;
}

static int lua_st_sixel_set_stripe(lua_State* L) {
    int x = luaL_checkinteger(L, 1);
    int y = luaL_checkinteger(L, 2);
    int stripe_index = luaL_checkinteger(L, 3);
    uint8_t color_index = (uint8_t)luaL_checkinteger(L, 4);
    
    st_sixel_set_stripe(x, y, stripe_index, color_index);
    return 0;
}

static int lua_st_sixel_get_stripe(lua_State* L) {
    int x = luaL_checkinteger(L, 1);
    int y = luaL_checkinteger(L, 2);
    int stripe_index = luaL_checkinteger(L, 3);
    
    uint8_t color = st_sixel_get_stripe(x, y, stripe_index);
    lua_pushinteger(L, color);
    return 1;
}

static int lua_st_sixel_gradient(lua_State* L) {
    int x = luaL_checkinteger(L, 1);
    int y = luaL_checkinteger(L, 2);
    uint8_t top_color = (uint8_t)luaL_checkinteger(L, 3);
    uint8_t bottom_color = (uint8_t)luaL_checkinteger(L, 4);
    uint32_t bg = luaL_optinteger(L, 5, 0xFF000000);
    
    st_sixel_gradient(x, y, top_color, bottom_color, bg);
    return 0;
}

static int lua_st_sixel_hline(lua_State* L) {
    int x = luaL_checkinteger(L, 1);
    int y = luaL_checkinteger(L, 2);
    int width = luaL_checkinteger(L, 3);
    uint32_t bg = luaL_optinteger(L, 5, 0xFF000000);
    
    // Get the colors table (6 elements)
    luaL_checktype(L, 4, LUA_TTABLE);
    uint8_t colors[6];
    for (int i = 0; i < 6; i++) {
        lua_rawgeti(L, 4, i + 1);
        colors[i] = (uint8_t)luaL_checkinteger(L, -1);
        lua_pop(L, 1);
    }
    
    st_sixel_hline(x, y, width, colors, bg);
    return 0;
}

static int lua_st_sixel_fill_rect(lua_State* L) {
    int x = luaL_checkinteger(L, 1);
    int y = luaL_checkinteger(L, 2);
    int width = luaL_checkinteger(L, 3);
    int height = luaL_checkinteger(L, 4);
    uint32_t bg = luaL_optinteger(L, 6, 0xFF000000);
    
    // Get the colors table (6 elements)
    luaL_checktype(L, 5, LUA_TTABLE);
    uint8_t colors[6];
    for (int i = 0; i < 6; i++) {
        lua_rawgeti(L, 5, i + 1);
        colors[i] = (uint8_t)luaL_checkinteger(L, -1);
        lua_pop(L, 1);
    }
    
    st_sixel_fill_rect(x, y, width, height, colors, bg);
    return 0;
}

// =============================================================================
// Graphics API Bindings
// =============================================================================

static int lua_st_gfx_clear(lua_State* L) {
    (void)L;
    st_gfx_clear();
    return 0;
}

static int lua_st_gfx_rect(lua_State* L) {
    int x = luaL_checkinteger(L, 1);
    int y = luaL_checkinteger(L, 2);
    int width = luaL_checkinteger(L, 3);
    int height = luaL_checkinteger(L, 4);
    uint32_t color = luaL_checkinteger(L, 5);
    
    st_gfx_rect(x, y, width, height, color);
    return 0;
}

static int lua_st_gfx_rect_outline(lua_State* L) {
    int x = luaL_checkinteger(L, 1);
    int y = luaL_checkinteger(L, 2);
    int width = luaL_checkinteger(L, 3);
    int height = luaL_checkinteger(L, 4);
    uint32_t color = luaL_checkinteger(L, 5);
    int thickness = luaL_optinteger(L, 6, 1);
    
    st_gfx_rect_outline(x, y, width, height, color, thickness);
    return 0;
}

static int lua_st_gfx_circle(lua_State* L) {
    int x = luaL_checkinteger(L, 1);
    int y = luaL_checkinteger(L, 2);
    int radius = luaL_checkinteger(L, 3);
    uint32_t color = luaL_checkinteger(L, 4);
    
    st_gfx_circle(x, y, radius, color);
    return 0;
}

static int lua_st_gfx_circle_outline(lua_State* L) {
    int x = luaL_checkinteger(L, 1);
    int y = luaL_checkinteger(L, 2);
    int radius = luaL_checkinteger(L, 3);
    uint32_t color = luaL_checkinteger(L, 4);
    int thickness = luaL_optinteger(L, 5, 1);
    
    st_gfx_circle_outline(x, y, radius, color, thickness);
    return 0;
}

static int lua_st_gfx_line(lua_State* L) {
    int x1 = luaL_checkinteger(L, 1);
    int y1 = luaL_checkinteger(L, 2);
    int x2 = luaL_checkinteger(L, 3);
    int y2 = luaL_checkinteger(L, 4);
    uint32_t color = luaL_checkinteger(L, 5);
    int thickness = luaL_optinteger(L, 6, 1);
    
    st_gfx_line(x1, y1, x2, y2, color, thickness);
    return 0;
}

static int lua_st_gfx_point(lua_State* L) {
    int x = luaL_checkinteger(L, 1);
    int y = luaL_checkinteger(L, 2);
    uint32_t color = luaL_checkinteger(L, 3);
    
    st_gfx_point(x, y, color);
    return 0;
}

// =============================================================================
// Audio API Bindings
// =============================================================================

static int lua_st_music_play(lua_State* L) {
    const char* abc = luaL_checkstring(L, 1);
    st_music_play(abc);
    return 0;
}

static int lua_st_music_play_file(lua_State* L) {
    const char* path = luaL_checkstring(L, 1);
    st_music_play_file(path);
    return 0;
}

static int lua_st_music_stop(lua_State* L) {
    (void)L;
    st_music_stop();
    return 0;
}

static int lua_st_music_pause(lua_State* L) {
    (void)L;
    st_music_pause();
    return 0;
}

static int lua_st_music_resume(lua_State* L) {
    (void)L;
    st_music_resume();
    return 0;
}

static int lua_st_music_is_playing(lua_State* L) {
    lua_pushboolean(L, st_music_is_playing());
    return 1;
}

static int lua_st_music_set_volume(lua_State* L) {
    float volume = luaL_checknumber(L, 1);
    st_music_set_volume(volume);
    return 0;
}

static int lua_st_synth_note(lua_State* L) {
    int note = luaL_checkinteger(L, 1);
    float duration = luaL_checknumber(L, 2);
    float volume = luaL_optnumber(L, 3, 0.5f);
    
    st_synth_note(note, duration, volume);
    return 0;
}

static int lua_st_synth_set_instrument(lua_State* L) {
    int instrument = luaL_checkinteger(L, 1);
    st_synth_set_instrument(instrument);
    return 0;
}

static int lua_st_synth_frequency(lua_State* L) {
    float frequency = luaL_checknumber(L, 1);
    float duration = luaL_checknumber(L, 2);
    float volume = luaL_optnumber(L, 3, 0.5f);
    
    st_synth_frequency(frequency, duration, volume);
    return 0;
}

// =============================================================================
// Input API Bindings
// =============================================================================

static int lua_st_key_pressed(lua_State* L) {
    int key = luaL_checkinteger(L, 1);
    lua_pushboolean(L, st_key_pressed((STKeyCode)key));
    return 1;
}

static int lua_st_key_just_pressed(lua_State* L) {
    int key = luaL_checkinteger(L, 1);
    lua_pushboolean(L, st_key_just_pressed((STKeyCode)key));
    return 1;
}

static int lua_st_key_just_released(lua_State* L) {
    int key = luaL_checkinteger(L, 1);
    lua_pushboolean(L, st_key_just_released((STKeyCode)key));
    return 1;
}

static int lua_st_key_get_char(lua_State* L) {
    uint32_t ch = st_key_get_char();
    if (ch) {
        char str[2] = { (char)ch, 0 };
        lua_pushstring(L, str);
    } else {
        lua_pushnil(L);
    }
    return 1;
}

static int lua_st_key_clear_buffer(lua_State* L) {
    (void)L;
    st_key_clear_buffer();
    return 0;
}

static int lua_st_mouse_position(lua_State* L) {
    int x, y;
    st_mouse_position(&x, &y);
    lua_pushinteger(L, x);
    lua_pushinteger(L, y);
    return 2;
}

static int lua_st_mouse_grid_position(lua_State* L) {
    int x, y;
    st_mouse_grid_position(&x, &y);
    lua_pushinteger(L, x);
    lua_pushinteger(L, y);
    return 2;
}

static int lua_st_mouse_button(lua_State* L) {
    int button = luaL_checkinteger(L, 1);
    lua_pushboolean(L, st_mouse_button((STMouseButton)button));
    return 1;
}

static int lua_st_mouse_button_just_pressed(lua_State* L) {
    int button = luaL_checkinteger(L, 1);
    lua_pushboolean(L, st_mouse_button_just_pressed((STMouseButton)button));
    return 1;
}

static int lua_st_mouse_button_just_released(lua_State* L) {
    int button = luaL_checkinteger(L, 1);
    lua_pushboolean(L, st_mouse_button_just_released((STMouseButton)button));
    return 1;
}

// =============================================================================
// Frame Control API Bindings
// =============================================================================

static int lua_st_wait_frame(lua_State* L) {
    (void)L;
    st_wait_frame();
    return 0;
}

static int lua_st_frame_count(lua_State* L) {
    lua_pushinteger(L, st_frame_count());
    return 1;
}

static int lua_st_time(lua_State* L) {
    lua_pushnumber(L, st_time());
    return 1;
}

static int lua_st_delta_time(lua_State* L) {
    lua_pushnumber(L, st_delta_time());
    return 1;
}

// =============================================================================
// Utility API Bindings
// =============================================================================

static int lua_st_rgb(lua_State* L) {
    int r = luaL_checkinteger(L, 1);
    int g = luaL_checkinteger(L, 2);
    int b = luaL_checkinteger(L, 3);
    
    lua_pushinteger(L, st_rgb(r, g, b));
    return 1;
}

static int lua_st_rgba(lua_State* L) {
    int r = luaL_checkinteger(L, 1);
    int g = luaL_checkinteger(L, 2);
    int b = luaL_checkinteger(L, 3);
    int a = luaL_checkinteger(L, 4);
    
    lua_pushinteger(L, st_rgba(r, g, b, a));
    return 1;
}

static int lua_st_hsv(lua_State* L) {
    float h = luaL_checknumber(L, 1);
    float s = luaL_checknumber(L, 2);
    float v = luaL_checknumber(L, 3);
    
    lua_pushinteger(L, st_hsv(h, s, v));
    return 1;
}

static int lua_st_debug_print(lua_State* L) {
    const char* msg = luaL_checkstring(L, 1);
    st_debug_print(msg);
    return 0;
}

// =============================================================================
// Display API Bindings
// =============================================================================

static int lua_st_display_size(lua_State* L) {
    int width, height;
    st_display_size(&width, &height);
    lua_pushinteger(L, width);
    lua_pushinteger(L, height);
    return 2;
}

static int lua_st_cell_size(lua_State* L) {
    int width, height;
    st_cell_size(&width, &height);
    lua_pushinteger(L, width);
    lua_pushinteger(L, height);
    return 2;
}

// =============================================================================
// Registration Function
// =============================================================================
// Chunky Pixel Graphics API Bindings
// =============================================================================

// DISABLED: chunky API no longer exists
/*
static int lua_st_chunky_pset(lua_State* L) {
    int pixel_x = luaL_checkinteger(L, 1);
    int pixel_y = luaL_checkinteger(L, 2);
    uint8_t color_index = (uint8_t)luaL_checkinteger(L, 3);
    uint32_t bg = luaL_optinteger(L, 4, 0xFF000000);
    
    st_chunky_pset(pixel_x, pixel_y, color_index, bg);
    return 0;
}
*/

/*
static int lua_st_chunky_line(lua_State* L) {
    int x1 = luaL_checkinteger(L, 1);
    int y1 = luaL_checkinteger(L, 2);
    int x2 = luaL_checkinteger(L, 3);
    int y2 = luaL_checkinteger(L, 4);
    uint8_t color_index = (uint8_t)luaL_checkinteger(L, 5);
    uint32_t bg = luaL_optinteger(L, 6, 0xFF000000);
    
    st_chunky_line(x1, y1, x2, y2, color_index, bg);
    return 0;
}
*/

/*
static int lua_st_chunky_rect(lua_State* L) {
    int x = luaL_checkinteger(L, 1);
    int y = luaL_checkinteger(L, 2);
    int width = luaL_checkinteger(L, 3);
    int height = luaL_checkinteger(L, 4);
    uint8_t color_index = (uint8_t)luaL_checkinteger(L, 5);
    uint32_t bg = luaL_optinteger(L, 6, 0xFF000000);
    
    st_chunky_rect(x, y, width, height, color_index, bg);
    return 0;
}
*/

/*
static int lua_st_chunky_fillrect(lua_State* L) {
    int x = luaL_checkinteger(L, 1);
    int y = luaL_checkinteger(L, 2);
    int width = luaL_checkinteger(L, 3);
    int height = luaL_checkinteger(L, 4);
    uint8_t color_index = (uint8_t)luaL_checkinteger(L, 5);
    uint32_t bg = luaL_optinteger(L, 6, 0xFF000000);
    
    st_chunky_fillrect(x, y, width, height, color_index, bg);
    return 0;
}
*/

/*
static int lua_st_chunky_hline(lua_State* L) {
    int x = luaL_checkinteger(L, 1);
    int y = luaL_checkinteger(L, 2);
    int width = luaL_checkinteger(L, 3);
    uint8_t color_index = (uint8_t)luaL_checkinteger(L, 4);
    uint32_t bg = luaL_optinteger(L, 5, 0xFF000000);
    
    st_chunky_hline(x, y, width, color_index, bg);
    return 0;
}
*/

/*
static int lua_st_chunky_vline(lua_State* L) {
    int x = luaL_checkinteger(L, 1);
    int y = luaL_checkinteger(L, 2);
    int height = luaL_checkinteger(L, 3);
    uint8_t color_index = (uint8_t)luaL_checkinteger(L, 4);
    uint32_t bg = luaL_optinteger(L, 5, 0xFF000000);
    
    st_chunky_vline(x, y, height, color_index, bg);
    return 0;
}
*/

/*
static int lua_st_chunky_clear(lua_State* L) {
    uint32_t bg = luaL_optinteger(L, 1, 0xFF000000);
    st_chunky_clear(bg);
    return 0;
}
*/

/*
static int lua_st_chunky_get_resolution(lua_State* L) {
    int width, height;
    st_chunky_get_resolution(&width, &height);
    
    lua_pushinteger(L, width);
    lua_pushinteger(L, height);
    return 2;
}
*/

// =============================================================================
// Particle System API Bindings
// =============================================================================

static int lua_st_sprite_explode(lua_State* L) {
    float x = luaL_checknumber(L, 1);
    float y = luaL_checknumber(L, 2);
    int particleCount = luaL_checkinteger(L, 3);
    uint32_t color = luaL_checkinteger(L, 4);
    
    bool result = st_sprite_explode(x, y, particleCount, color);
    lua_pushboolean(L, result);
    return 1;
}

static int lua_st_sprite_explode_advanced(lua_State* L) {
    float x = luaL_checknumber(L, 1);
    float y = luaL_checknumber(L, 2);
    int particleCount = luaL_checkinteger(L, 3);
    uint32_t color = luaL_checkinteger(L, 4);
    float force = luaL_checknumber(L, 5);
    float gravity = luaL_checknumber(L, 6);
    float fadeTime = luaL_checknumber(L, 7);
    
    bool result = st_sprite_explode_advanced(x, y, particleCount, color, force, gravity, fadeTime);
    lua_pushboolean(L, result);
    return 1;
}

static int lua_st_sprite_explode_directional(lua_State* L) {
    float x = luaL_checknumber(L, 1);
    float y = luaL_checknumber(L, 2);
    int particleCount = luaL_checkinteger(L, 3);
    uint32_t color = luaL_checkinteger(L, 4);
    float forceX = luaL_checknumber(L, 5);
    float forceY = luaL_checknumber(L, 6);
    
    bool result = st_sprite_explode_directional(x, y, particleCount, color, forceX, forceY);
    lua_pushboolean(L, result);
    return 1;
}

static int lua_st_particle_clear(lua_State* L) {
    st_particle_clear();
    return 0;
}

static int lua_st_particle_pause(lua_State* L) {
    st_particle_pause();
    return 0;
}

static int lua_st_particle_resume(lua_State* L) {
    st_particle_resume();
    return 0;
}

static int lua_st_particle_set_time_scale(lua_State* L) {
    float scale = luaL_checknumber(L, 1);
    st_particle_set_time_scale(scale);
    return 0;
}

static int lua_st_particle_set_world_bounds(lua_State* L) {
    float width = luaL_checknumber(L, 1);
    float height = luaL_checknumber(L, 2);
    st_particle_set_world_bounds(width, height);
    return 0;
}

static int lua_st_particle_set_enabled(lua_State* L) {
    bool enabled = lua_toboolean(L, 1);
    st_particle_set_enabled(enabled);
    return 0;
}

static int lua_st_particle_get_active_count(lua_State* L) {
    uint32_t count = st_particle_get_active_count();
    lua_pushinteger(L, count);
    return 1;
}

static int lua_st_particle_get_total_created(lua_State* L) {
    uint64_t total = st_particle_get_total_created();
    lua_pushinteger(L, total);
    return 1;
}

static int lua_st_particle_dump_stats(lua_State* L) {
    st_particle_dump_stats();
    return 0;
}

// =============================================================================
// Sprite Management API
// =============================================================================

static int lua_st_sprite_load(lua_State* L) {
    const char* path = luaL_checkstring(L, 1);
    int sprite_id = st_sprite_load(path);
    lua_pushinteger(L, sprite_id);
    return 1;
}

static int lua_st_sprite_load_builtin(lua_State* L) {
    const char* name = luaL_checkstring(L, 1);
    int sprite_id = st_sprite_load_builtin(name);
    lua_pushinteger(L, sprite_id);
    return 1;
}

static int lua_st_sprite_show(lua_State* L) {
    int sprite_id = luaL_checkinteger(L, 1);
    int x = luaL_checkinteger(L, 2);
    int y = luaL_checkinteger(L, 3);
    st_sprite_show(sprite_id, x, y);
    return 0;
}

static int lua_st_sprite_hide(lua_State* L) {
    int sprite_id = luaL_checkinteger(L, 1);
    st_sprite_hide(sprite_id);
    return 0;
}

static int lua_st_sprite_transform(lua_State* L) {
    int sprite_id = luaL_checkinteger(L, 1);
    int x = luaL_checkinteger(L, 2);
    int y = luaL_checkinteger(L, 3);
    float rotation = luaL_checknumber(L, 4);
    float scale_x = luaL_checknumber(L, 5);
    float scale_y = luaL_checknumber(L, 6);
    st_sprite_transform(sprite_id, x, y, rotation, scale_x, scale_y);
    return 0;
}

static int lua_st_sprite_tint(lua_State* L) {
    int sprite_id = luaL_checkinteger(L, 1);
    uint32_t color = luaL_checkinteger(L, 2);
    st_sprite_tint(sprite_id, color);
    return 0;
}

static int lua_st_sprite_unload(lua_State* L) {
    int sprite_id = luaL_checkinteger(L, 1);
    st_sprite_unload(sprite_id);
    return 0;
}

// =============================================================================
// Sprite-based Particle Explosion API (v1 compatible)
// =============================================================================

static int lua_sprite_explode(lua_State* L) {
    int sprite_id = luaL_checkinteger(L, 1);
    int particle_count = 32; // Default
    
    if (lua_gettop(L) >= 2) {
        particle_count = luaL_checkinteger(L, 2);
    }
    
    // Optional mode parameter (default to SPRITE_FRAGMENT for v1 compatibility)
    ParticleMode mode = ParticleMode::SPRITE_FRAGMENT;
    if (lua_gettop(L) >= 3) {
        int mode_int = luaL_checkinteger(L, 3);
        mode = (mode_int == 1) ? ParticleMode::SPRITE_FRAGMENT : ParticleMode::POINT_SPRITE;
    }
    
    // Validate parameters
    if (sprite_id < 1 || sprite_id > 1024) {
        return luaL_error(L, "sprite_explode: sprite_id must be between 1 and 1024");
    }
    
    if (particle_count < 1 || particle_count > 500) {
        return luaL_error(L, "sprite_explode: particle_count must be between 1 and 500");
    }
    
    bool result = sprite_explode((uint16_t)sprite_id, (uint16_t)particle_count);
    lua_pushboolean(L, result);
    return 1;
}

static int lua_sprite_explode_advanced(lua_State* L) {
    int sprite_id = luaL_checkinteger(L, 1);
    int particle_count = luaL_checkinteger(L, 2);
    
    // Get optional parameters with defaults
    float explosion_force = 200.0f;
    float gravity = 100.0f;
    float fade_time = 2.0f;
    
    if (lua_gettop(L) >= 3) explosion_force = luaL_checknumber(L, 3);
    if (lua_gettop(L) >= 4) gravity = luaL_checknumber(L, 4);
    if (lua_gettop(L) >= 5) fade_time = luaL_checknumber(L, 5);
    
    // Optional mode parameter (default to SPRITE_FRAGMENT for v1 compatibility)
    ParticleMode mode = ParticleMode::SPRITE_FRAGMENT;
    if (lua_gettop(L) >= 6) {
        int mode_int = luaL_checkinteger(L, 6);
        mode = (mode_int == 1) ? ParticleMode::SPRITE_FRAGMENT : ParticleMode::POINT_SPRITE;
    }
    
    // Validate parameters
    if (sprite_id < 1 || sprite_id > 1024) {
        return luaL_error(L, "sprite_explode_advanced: sprite_id must be between 1 and 1024");
    }
    
    if (particle_count < 1 || particle_count > 500) {
        return luaL_error(L, "sprite_explode_advanced: particle_count must be between 1 and 500");
    }
    
    bool result = sprite_explode_advanced((uint16_t)sprite_id, (uint16_t)particle_count,
                                         explosion_force, gravity, fade_time);
    lua_pushboolean(L, result);
    return 1;
}

static int lua_sprite_explode_directional(lua_State* L) {
    int sprite_id = luaL_checkinteger(L, 1);
    int particle_count = luaL_checkinteger(L, 2);
    float force_x = luaL_checknumber(L, 3);
    float force_y = luaL_checknumber(L, 4);
    
    // Validate parameters
    if (sprite_id < 1 || sprite_id > 1024) {
        return luaL_error(L, "sprite_explode_directional: sprite_id must be between 1 and 1024");
    }
    
    if (particle_count < 1 || particle_count > 500) {
        return luaL_error(L, "sprite_explode_directional: particle_count must be between 1 and 500");
    }
    
    bool result = sprite_explode_directional((uint16_t)sprite_id, (uint16_t)particle_count,
                                            force_x, force_y);
    lua_pushboolean(L, result);
    return 1;
}

static int lua_sprite_explode_mode(lua_State* L) {
    int sprite_id = luaL_checkinteger(L, 1);
    int explosion_mode = luaL_checkinteger(L, 2);
    
    // Validate sprite ID
    if (sprite_id < 1 || sprite_id > 1024) {
        return luaL_error(L, "sprite_explode_mode: sprite_id must be between 1 and 1024");
    }
    
    // Validate explosion mode
    if (explosion_mode < 1 || explosion_mode > 6) {
        return luaL_error(L, "sprite_explode_mode: explosion_mode must be between 1 and 6");
    }
    
    bool success = false;
    
    // Apply the appropriate explosion mode
    switch (explosion_mode) {
        case 1: // BASIC_EXPLOSION
            success = sprite_explode_advanced((uint16_t)sprite_id, 48, 200.0f, 100.0f, 2.0f);
            break;
        case 2: // MASSIVE_BLAST
            success = sprite_explode_advanced((uint16_t)sprite_id, 128, 350.0f, 80.0f, 3.0f);
            break;
        case 3: // GENTLE_DISPERSAL
            success = sprite_explode_advanced((uint16_t)sprite_id, 64, 120.0f, 40.0f, 4.0f);
            break;
        case 4: // RIGHTWARD_BLAST
            success = sprite_explode_directional((uint16_t)sprite_id, 80, 180.0f, -30.0f);
            break;
        case 5: // UPWARD_ERUPTION
            success = sprite_explode_directional((uint16_t)sprite_id, 96, 0.0f, -250.0f);
            break;
        case 6: // RAPID_BURST
            success = sprite_explode_advanced((uint16_t)sprite_id, 32, 400.0f, 200.0f, 1.0f);
            break;
        default:
            return luaL_error(L, "sprite_explode_mode: invalid explosion_mode");
    }
    
    lua_pushboolean(L, success);
    return 1;
}

// =============================================================================
// Asset Management API Bindings
// =============================================================================

// Initialization
static int lua_st_asset_init(lua_State* L) {
    const char* db_path = luaL_checkstring(L, 1);
    size_t max_cache_size = luaL_optinteger(L, 2, 0);
    
    bool result = st_asset_init(db_path, max_cache_size);
    lua_pushboolean(L, result);
    return 1;
}

static int lua_st_asset_shutdown(lua_State* L) {
    (void)L;
    st_asset_shutdown();
    return 0;
}

static int lua_st_asset_is_initialized(lua_State* L) {
    (void)L;
    bool result = st_asset_is_initialized();
    lua_pushboolean(L, result);
    return 1;
}

// Loading/Unloading
static int lua_st_asset_load(lua_State* L) {
    const char* name = luaL_checkstring(L, 1);
    
    STAssetID asset = st_asset_load(name);
    lua_pushinteger(L, asset);
    return 1;
}

static int lua_st_asset_load_file(lua_State* L) {
    const char* path = luaL_checkstring(L, 1);
    int type = luaL_checkinteger(L, 2);
    
    STAssetID asset = st_asset_load_file(path, (STAssetType)type);
    lua_pushinteger(L, asset);
    return 1;
}

static int lua_st_asset_unload(lua_State* L) {
    STAssetID asset = luaL_checkinteger(L, 1);
    st_asset_unload(asset);
    return 0;
}

static int lua_st_asset_is_loaded(lua_State* L) {
    const char* name = luaL_checkstring(L, 1);
    
    bool result = st_asset_is_loaded(name);
    lua_pushboolean(L, result);
    return 1;
}

// Import/Export
static int lua_st_asset_import(lua_State* L) {
    const char* file_path = luaL_checkstring(L, 1);
    const char* asset_name = luaL_checkstring(L, 2);
    int type = luaL_optinteger(L, 3, -1);
    
    bool result = st_asset_import(file_path, asset_name, type);
    lua_pushboolean(L, result);
    return 1;
}

static int lua_st_asset_import_directory(lua_State* L) {
    const char* directory = luaL_checkstring(L, 1);
    bool recursive = lua_toboolean(L, 2);
    
    int count = st_asset_import_directory(directory, recursive);
    lua_pushinteger(L, count);
    return 1;
}

static int lua_st_asset_export(lua_State* L) {
    const char* asset_name = luaL_checkstring(L, 1);
    const char* file_path = luaL_checkstring(L, 2);
    
    bool result = st_asset_export(asset_name, file_path);
    lua_pushboolean(L, result);
    return 1;
}

static int lua_st_asset_delete(lua_State* L) {
    const char* asset_name = luaL_checkstring(L, 1);
    
    bool result = st_asset_delete(asset_name);
    lua_pushboolean(L, result);
    return 1;
}

// Data Access
static int lua_st_asset_get_data(lua_State* L) {
    STAssetID asset = luaL_checkinteger(L, 1);
    
    const void* data = st_asset_get_data(asset);
    size_t size = st_asset_get_size(asset);
    
    if (data && size > 0) {
        lua_pushlstring(L, (const char*)data, size);
        return 1;
    }
    
    lua_pushnil(L);
    return 1;
}

static int lua_st_asset_get_size(lua_State* L) {
    STAssetID asset = luaL_checkinteger(L, 1);
    
    size_t size = st_asset_get_size(asset);
    lua_pushinteger(L, size);
    return 1;
}

static int lua_st_asset_get_type(lua_State* L) {
    STAssetID asset = luaL_checkinteger(L, 1);
    
    int type = st_asset_get_type(asset);
    lua_pushinteger(L, type);
    return 1;
}

static int lua_st_asset_get_name(lua_State* L) {
    STAssetID asset = luaL_checkinteger(L, 1);
    
    const char* name = st_asset_get_name(asset);
    if (name) {
        lua_pushstring(L, name);
    } else {
        lua_pushnil(L);
    }
    return 1;
}

// Queries
static int lua_st_asset_exists(lua_State* L) {
    const char* name = luaL_checkstring(L, 1);
    
    bool result = st_asset_exists(name);
    lua_pushboolean(L, result);
    return 1;
}

static int lua_st_asset_list(lua_State* L) {
    int type = luaL_optinteger(L, 1, -1);
    
    // Get count first
    int count = st_asset_list(type, nullptr, 0);
    
    if (count <= 0) {
        lua_newtable(L);
        return 1;
    }
    
    // Allocate array for names
    const char** names = new const char*[count];
    st_asset_list(type, names, count);
    
    // Create Lua table
    lua_createtable(L, count, 0);
    for (int i = 0; i < count; i++) {
        lua_pushstring(L, names[i]);
        lua_rawseti(L, -2, i + 1);  // Lua arrays are 1-indexed
    }
    
    delete[] names;
    return 1;
}

static int lua_st_asset_search(lua_State* L) {
    const char* pattern = luaL_checkstring(L, 1);
    
    // Get count first
    int count = st_asset_search(pattern, nullptr, 0);
    
    if (count <= 0) {
        lua_newtable(L);
        return 1;
    }
    
    // Allocate array for names
    const char** names = new const char*[count];
    st_asset_search(pattern, names, count);
    
    // Create Lua table
    lua_createtable(L, count, 0);
    for (int i = 0; i < count; i++) {
        lua_pushstring(L, names[i]);
        lua_rawseti(L, -2, i + 1);
    }
    
    delete[] names;
    return 1;
}

static int lua_st_asset_get_count(lua_State* L) {
    int type = luaL_optinteger(L, 1, -1);
    
    int count = st_asset_get_count(type);
    lua_pushinteger(L, count);
    return 1;
}

// Cache Management
static int lua_st_asset_clear_cache(lua_State* L) {
    (void)L;
    st_asset_clear_cache();
    return 0;
}

static int lua_st_asset_get_cache_size(lua_State* L) {
    (void)L;
    size_t size = st_asset_get_cache_size();
    lua_pushinteger(L, size);
    return 1;
}

static int lua_st_asset_get_cached_count(lua_State* L) {
    (void)L;
    int count = st_asset_get_cached_count();
    lua_pushinteger(L, count);
    return 1;
}

static int lua_st_asset_set_max_cache_size(lua_State* L) {
    size_t max_size = luaL_checkinteger(L, 1);
    st_asset_set_max_cache_size(max_size);
    return 0;
}

// Statistics
static int lua_st_asset_get_hit_rate(lua_State* L) {
    (void)L;
    double rate = st_asset_get_hit_rate();
    lua_pushnumber(L, rate);
    return 1;
}

static int lua_st_asset_get_database_size(lua_State* L) {
    (void)L;
    size_t size = st_asset_get_database_size();
    lua_pushinteger(L, size);
    return 1;
}

// Error Handling
static int lua_st_asset_get_error(lua_State* L) {
    (void)L;
    const char* error = st_asset_get_error();
    if (error) {
        lua_pushstring(L, error);
    } else {
        lua_pushnil(L);
    }
    return 1;
}

static int lua_st_asset_clear_error(lua_State* L) {
    (void)L;
    st_asset_clear_error();
    return 0;
}

// =============================================================================
// Tilemap API
// =============================================================================

static int lua_st_tilemap_init(lua_State* L) {
    float width = (float)luaL_checknumber(L, 1);
    float height = (float)luaL_checknumber(L, 2);
    bool result = st_tilemap_init(width, height);
    lua_pushboolean(L, result);
    return 1;
}

static int lua_st_tilemap_shutdown(lua_State* L) {
    (void)L;
    st_tilemap_shutdown();
    return 0;
}

static int lua_st_tilemap_create(lua_State* L) {
    int32_t width = (int32_t)luaL_checkinteger(L, 1);
    int32_t height = (int32_t)luaL_checkinteger(L, 2);
    int32_t tileWidth = (int32_t)luaL_checkinteger(L, 3);
    int32_t tileHeight = (int32_t)luaL_checkinteger(L, 4);
    STTilemapID id = st_tilemap_create(width, height, tileWidth, tileHeight);
    lua_pushinteger(L, id);
    return 1;
}

static int lua_st_tilemap_destroy(lua_State* L) {
    STTilemapID id = (STTilemapID)luaL_checkinteger(L, 1);
    st_tilemap_destroy(id);
    return 0;
}

static int lua_st_tilemap_get_size(lua_State* L) {
    STTilemapID id = (STTilemapID)luaL_checkinteger(L, 1);
    int32_t width, height;
    st_tilemap_get_size(id, &width, &height);
    lua_pushinteger(L, width);
    lua_pushinteger(L, height);
    return 2;
}

static int lua_st_tilemap_create_layer(lua_State* L) {
    const char* name = lua_isstring(L, 1) ? lua_tostring(L, 1) : nullptr;
    STLayerID id = st_tilemap_create_layer(name);
    lua_pushinteger(L, id);
    return 1;
}

static int lua_st_tilemap_destroy_layer(lua_State* L) {
    STLayerID id = (STLayerID)luaL_checkinteger(L, 1);
    st_tilemap_destroy_layer(id);
    return 0;
}

static int lua_st_tilemap_layer_set_tilemap(lua_State* L) {
    STLayerID layer = (STLayerID)luaL_checkinteger(L, 1);
    STTilemapID tilemap = (STTilemapID)luaL_checkinteger(L, 2);
    st_tilemap_layer_set_tilemap(layer, tilemap);
    return 0;
}

static int lua_st_tilemap_layer_set_parallax(lua_State* L) {
    STLayerID layer = (STLayerID)luaL_checkinteger(L, 1);
    float parallaxX = (float)luaL_checknumber(L, 2);
    float parallaxY = (float)luaL_checknumber(L, 3);
    st_tilemap_layer_set_parallax(layer, parallaxX, parallaxY);
    return 0;
}

static int lua_st_tilemap_layer_set_opacity(lua_State* L) {
    STLayerID layer = (STLayerID)luaL_checkinteger(L, 1);
    float opacity = (float)luaL_checknumber(L, 2);
    st_tilemap_layer_set_opacity(layer, opacity);
    return 0;
}

static int lua_st_tilemap_layer_set_visible(lua_State* L) {
    STLayerID layer = (STLayerID)luaL_checkinteger(L, 1);
    bool visible = lua_toboolean(L, 2);
    st_tilemap_layer_set_visible(layer, visible);
    return 0;
}

static int lua_st_tilemap_layer_set_z_order(lua_State* L) {
    STLayerID layer = (STLayerID)luaL_checkinteger(L, 1);
    int32_t zOrder = (int32_t)luaL_checkinteger(L, 2);
    st_tilemap_layer_set_z_order(layer, zOrder);
    return 0;
}

static int lua_st_tilemap_layer_set_auto_scroll(lua_State* L) {
    STLayerID layer = (STLayerID)luaL_checkinteger(L, 1);
    float scrollX = (float)luaL_checknumber(L, 2);
    float scrollY = (float)luaL_checknumber(L, 3);
    st_tilemap_layer_set_auto_scroll(layer, scrollX, scrollY);
    return 0;
}

static int lua_st_tilemap_set_tile(lua_State* L) {
    STLayerID layer = (STLayerID)luaL_checkinteger(L, 1);
    int32_t x = (int32_t)luaL_checkinteger(L, 2);
    int32_t y = (int32_t)luaL_checkinteger(L, 3);
    uint16_t tileID = (uint16_t)luaL_checkinteger(L, 4);
    st_tilemap_set_tile(layer, x, y, tileID);
    return 0;
}

static int lua_st_tilemap_get_tile(lua_State* L) {
    STLayerID layer = (STLayerID)luaL_checkinteger(L, 1);
    int32_t x = (int32_t)luaL_checkinteger(L, 2);
    int32_t y = (int32_t)luaL_checkinteger(L, 3);
    uint16_t tileID = st_tilemap_get_tile(layer, x, y);
    lua_pushinteger(L, tileID);
    return 1;
}

static int lua_st_tilemap_fill_rect(lua_State* L) {
    STLayerID layer = (STLayerID)luaL_checkinteger(L, 1);
    int32_t x = (int32_t)luaL_checkinteger(L, 2);
    int32_t y = (int32_t)luaL_checkinteger(L, 3);
    int32_t width = (int32_t)luaL_checkinteger(L, 4);
    int32_t height = (int32_t)luaL_checkinteger(L, 5);
    uint16_t tileID = (uint16_t)luaL_checkinteger(L, 6);
    st_tilemap_fill_rect(layer, x, y, width, height, tileID);
    return 0;
}

static int lua_st_tilemap_clear(lua_State* L) {
    STLayerID layer = (STLayerID)luaL_checkinteger(L, 1);
    st_tilemap_clear(layer);
    return 0;
}

static int lua_st_tilemap_set_camera(lua_State* L) {
    float x = (float)luaL_checknumber(L, 1);
    float y = (float)luaL_checknumber(L, 2);
    st_tilemap_set_camera(x, y);
    return 0;
}

static int lua_st_tilemap_move_camera(lua_State* L) {
    float dx = (float)luaL_checknumber(L, 1);
    float dy = (float)luaL_checknumber(L, 2);
    st_tilemap_move_camera(dx, dy);
    return 0;
}

static int lua_st_tilemap_get_camera(lua_State* L) {
    float x, y;
    st_tilemap_get_camera(&x, &y);
    lua_pushnumber(L, x);
    lua_pushnumber(L, y);
    return 2;
}

static int lua_st_tilemap_set_zoom(lua_State* L) {
    float zoom = (float)luaL_checknumber(L, 1);
    st_tilemap_set_zoom(zoom);
    return 0;
}

static int lua_st_tilemap_camera_follow(lua_State* L) {
    float targetX = (float)luaL_checknumber(L, 1);
    float targetY = (float)luaL_checknumber(L, 2);
    float smoothness = (float)luaL_checknumber(L, 3);
    st_tilemap_camera_follow(targetX, targetY, smoothness);
    return 0;
}

static int lua_st_tilemap_set_camera_bounds(lua_State* L) {
    float x = (float)luaL_checknumber(L, 1);
    float y = (float)luaL_checknumber(L, 2);
    float width = (float)luaL_checknumber(L, 3);
    float height = (float)luaL_checknumber(L, 4);
    st_tilemap_set_camera_bounds(x, y, width, height);
    return 0;
}

static int lua_st_tilemap_camera_shake(lua_State* L) {
    float magnitude = (float)luaL_checknumber(L, 1);
    float duration = (float)luaL_checknumber(L, 2);
    st_tilemap_camera_shake(magnitude, duration);
    return 0;
}

static int lua_st_tilemap_update(lua_State* L) {
    float dt = (float)luaL_checknumber(L, 1);
    st_tilemap_update(dt);
    return 0;
}

static int lua_st_tilemap_world_to_tile(lua_State* L) {
    STLayerID layer = (STLayerID)luaL_checkinteger(L, 1);
    float worldX = (float)luaL_checknumber(L, 2);
    float worldY = (float)luaL_checknumber(L, 3);
    int32_t tileX, tileY;
    st_tilemap_world_to_tile(layer, worldX, worldY, &tileX, &tileY);
    lua_pushinteger(L, tileX);
    lua_pushinteger(L, tileY);
    return 2;
}

static int lua_st_tilemap_tile_to_world(lua_State* L) {
    STLayerID layer = (STLayerID)luaL_checkinteger(L, 1);
    int32_t tileX = (int32_t)luaL_checkinteger(L, 2);
    int32_t tileY = (int32_t)luaL_checkinteger(L, 3);
    float worldX, worldY;
    st_tilemap_tile_to_world(layer, tileX, tileY, &worldX, &worldY);
    lua_pushnumber(L, worldX);
    lua_pushnumber(L, worldY);
    return 2;
}

// Error handling API
static int lua_st_get_error(lua_State* L) {
    const char* error = st_get_last_error();
    if (error && error[0] != '\0') {
        lua_pushstring(L, error);
    } else {
        lua_pushnil(L);
    }
    return 1;
}

static int lua_st_clear_error(lua_State* L) {
    (void)L;
    st_clear_error();
    return 0;
}

// Tileset API
static int lua_st_tileset_load(lua_State* L) {
    const char* imagePath = luaL_checkstring(L, 1);
    int32_t tileWidth = (int32_t)luaL_checkinteger(L, 2);
    int32_t tileHeight = (int32_t)luaL_checkinteger(L, 3);
    int32_t margin = (int32_t)luaL_optinteger(L, 4, 0);
    int32_t spacing = (int32_t)luaL_optinteger(L, 5, 0);
    STTilesetID id = st_tileset_load(imagePath, tileWidth, tileHeight, margin, spacing);
    lua_pushinteger(L, id);
    return 1;
}

static int lua_st_tileset_load_asset(lua_State* L) {
    const char* assetName = luaL_checkstring(L, 1);
    int32_t tileWidth = (int32_t)luaL_checkinteger(L, 2);
    int32_t tileHeight = (int32_t)luaL_checkinteger(L, 3);
    int32_t margin = (int32_t)luaL_optinteger(L, 4, 0);
    int32_t spacing = (int32_t)luaL_optinteger(L, 5, 0);
    STTilesetID id = st_tileset_load_asset(assetName, tileWidth, tileHeight, margin, spacing);
    lua_pushinteger(L, id);
    return 1;
}

static int lua_st_tileset_destroy(lua_State* L) {
    STTilesetID id = (STTilesetID)luaL_checkinteger(L, 1);
    st_tileset_destroy(id);
    return 0;
}

static int lua_st_tileset_get_tile_count(lua_State* L) {
    STTilesetID id = (STTilesetID)luaL_checkinteger(L, 1);
    int32_t count = st_tileset_get_tile_count(id);
    lua_pushinteger(L, count);
    return 1;
}

static int lua_st_tileset_get_dimensions(lua_State* L) {
    STTilesetID id = (STTilesetID)luaL_checkinteger(L, 1);
    int32_t columns, rows;
    st_tileset_get_dimensions(id, &columns, &rows);
    lua_pushinteger(L, columns);
    lua_pushinteger(L, rows);
    return 2;
}

static int lua_st_tilemap_layer_set_tileset(lua_State* L) {
    STLayerID layer = (STLayerID)luaL_checkinteger(L, 1);
    STTilesetID tileset = (STTilesetID)luaL_checkinteger(L, 2);
    st_tilemap_layer_set_tileset(layer, tileset);
    return 0;
}

// =============================================================================
// DisplayText API Bindings
// =============================================================================

static int lua_st_text_display_at(lua_State* L) {
    float x = (float)luaL_checknumber(L, 1);
    float y = (float)luaL_checknumber(L, 2);
    const char* text = luaL_checkstring(L, 3);
    float scale_x = (float)luaL_optnumber(L, 4, 1.0);
    float scale_y = (float)luaL_optnumber(L, 5, 1.0);
    float rotation = (float)luaL_optnumber(L, 6, 0.0);
    uint32_t color = (uint32_t)luaL_optinteger(L, 7, 0xFFFFFFFF);
    int alignment = (int)luaL_optinteger(L, 8, 0); // ST_ALIGN_LEFT
    int layer = (int)luaL_optinteger(L, 9, 0);
    
    int item_id = st_text_display_at(x, y, text, scale_x, scale_y, rotation, color, alignment, layer);
    lua_pushinteger(L, item_id);
    return 1;
}

static int lua_st_text_display_shear(lua_State* L) {
    float x = (float)luaL_checknumber(L, 1);
    float y = (float)luaL_checknumber(L, 2);
    const char* text = luaL_checkstring(L, 3);
    float scale_x = (float)luaL_optnumber(L, 4, 1.0);
    float scale_y = (float)luaL_optnumber(L, 5, 1.0);
    float rotation = (float)luaL_optnumber(L, 6, 0.0);
    float shear_x = (float)luaL_optnumber(L, 7, 0.0);
    float shear_y = (float)luaL_optnumber(L, 8, 0.0);
    uint32_t color = (uint32_t)luaL_optinteger(L, 9, 0xFFFFFFFF);
    int alignment = (int)luaL_optinteger(L, 10, 0); // ST_ALIGN_LEFT
    int layer = (int)luaL_optinteger(L, 11, 0);
    
    int item_id = st_text_display_shear(x, y, text, scale_x, scale_y, rotation, shear_x, shear_y, color, alignment, layer);
    lua_pushinteger(L, item_id);
    return 1;
}

static int lua_st_text_update_item(lua_State* L) {
    int item_id = (int)luaL_checkinteger(L, 1);
    const char* text = luaL_optstring(L, 2, nullptr);
    float x = (float)luaL_optnumber(L, 3, -1.0);
    float y = (float)luaL_optnumber(L, 4, -1.0);
    
    st_text_update_item(item_id, text, x, y);
    return 0;
}

static int lua_st_text_remove_item(lua_State* L) {
    int item_id = (int)luaL_checkinteger(L, 1);
    st_text_remove_item(item_id);
    return 0;
}

static int lua_st_text_clear_displayed(lua_State* L) {
    (void)L;
    st_text_clear_displayed();
    return 0;
}

static int lua_st_text_set_item_visible(lua_State* L) {
    int item_id = (int)luaL_checkinteger(L, 1);
    bool visible = lua_toboolean(L, 2);
    st_text_set_item_visible(item_id, visible);
    return 0;
}

static int lua_st_text_set_item_layer(lua_State* L) {
    int item_id = (int)luaL_checkinteger(L, 1);
    int layer = (int)luaL_checkinteger(L, 2);
    st_text_set_item_layer(item_id, layer);
    return 0;
}

static int lua_st_text_get_item_count(lua_State* L) {
    int count = st_text_get_item_count();
    lua_pushinteger(L, count);
    return 1;
}

static int lua_st_text_get_visible_count(lua_State* L) {
    int count = st_text_get_visible_count();
    lua_pushinteger(L, count);
    return 1;
}

// =============================================================================

void registerBindings(lua_State* L) {
    // Text API
    luaL_setglobalfunction(L, "text_putchar", lua_st_text_putchar);
    luaL_setglobalfunction(L, "poke_text", lua_poke_text);
    luaL_setglobalfunction(L, "text_put", lua_st_text_put);
    luaL_setglobalfunction(L, "text_clear", lua_st_text_clear);
    luaL_setglobalfunction(L, "text_clear_region", lua_st_text_clear_region);
    luaL_setglobalfunction(L, "text_set_size", lua_st_text_set_size);
    luaL_setglobalfunction(L, "text_get_size", lua_st_text_get_size);
    luaL_setglobalfunction(L, "text_scroll", lua_st_text_scroll);
    
    // Sixel API
    luaL_setglobalfunction(L, "text_putsixel", lua_st_text_putsixel);
    luaL_setglobalfunction(L, "text_putsixel_packed", lua_st_text_putsixel_packed);
    luaL_setglobalfunction(L, "sixel_pack_colors", lua_st_sixel_pack_colors);
    luaL_setglobalfunction(L, "sixel_set_stripe", lua_st_sixel_set_stripe);
    luaL_setglobalfunction(L, "sixel_get_stripe", lua_st_sixel_get_stripe);
    luaL_setglobalfunction(L, "sixel_gradient", lua_st_sixel_gradient);
    luaL_setglobalfunction(L, "sixel_hline", lua_st_sixel_hline);
    luaL_setglobalfunction(L, "sixel_fill_rect", lua_st_sixel_fill_rect);
    
    // Chunky Pixel Graphics API
    luaL_setglobalfunction(L, "pset", lua_st_chunky_pset);
    luaL_setglobalfunction(L, "line", lua_st_chunky_line);
    luaL_setglobalfunction(L, "rect", lua_st_chunky_rect);
    luaL_setglobalfunction(L, "fillrect", lua_st_chunky_fillrect);
    luaL_setglobalfunction(L, "hline", lua_st_chunky_hline);
    luaL_setglobalfunction(L, "vline", lua_st_chunky_vline);
    luaL_setglobalfunction(L, "chunky_clear", lua_st_chunky_clear);
    luaL_setglobalfunction(L, "chunky_resolution", lua_st_chunky_get_resolution);
    
    // Graphics API
    luaL_setglobalfunction(L, "gfx_clear", lua_st_gfx_clear);
    luaL_setglobalfunction(L, "gfx_rect", lua_st_gfx_rect);
    luaL_setglobalfunction(L, "gfx_rect_outline", lua_st_gfx_rect_outline);
    luaL_setglobalfunction(L, "gfx_circle", lua_st_gfx_circle);
    luaL_setglobalfunction(L, "gfx_circle_outline", lua_st_gfx_circle_outline);
    luaL_setglobalfunction(L, "gfx_line", lua_st_gfx_line);
    luaL_setglobalfunction(L, "gfx_point", lua_st_gfx_point);
    
    // Audio API
    luaL_setglobalfunction(L, "music_play", lua_st_music_play);
    luaL_setglobalfunction(L, "music_play_file", lua_st_music_play_file);
    luaL_setglobalfunction(L, "music_stop", lua_st_music_stop);
    luaL_setglobalfunction(L, "music_pause", lua_st_music_pause);
    luaL_setglobalfunction(L, "music_resume", lua_st_music_resume);
    luaL_setglobalfunction(L, "music_is_playing", lua_st_music_is_playing);
    luaL_setglobalfunction(L, "music_set_volume", lua_st_music_set_volume);
    luaL_setglobalfunction(L, "synth_note", lua_st_synth_note);
    luaL_setglobalfunction(L, "synth_set_instrument", lua_st_synth_set_instrument);
    luaL_setglobalfunction(L, "synth_frequency", lua_st_synth_frequency);
    
    // Input API
    luaL_setglobalfunction(L, "key_pressed", lua_st_key_pressed);
    luaL_setglobalfunction(L, "key_just_pressed", lua_st_key_just_pressed);
    luaL_setglobalfunction(L, "key_just_released", lua_st_key_just_released);
    luaL_setglobalfunction(L, "key_get_char", lua_st_key_get_char);
    luaL_setglobalfunction(L, "key_clear_buffer", lua_st_key_clear_buffer);
    luaL_setglobalfunction(L, "mouse_position", lua_st_mouse_position);
    luaL_setglobalfunction(L, "mouse_grid_position", lua_st_mouse_grid_position);
    luaL_setglobalfunction(L, "mouse_button", lua_st_mouse_button);
    luaL_setglobalfunction(L, "mouse_button_just_pressed", lua_st_mouse_button_just_pressed);
    luaL_setglobalfunction(L, "mouse_button_just_released", lua_st_mouse_button_just_released);
    
    // Frame Control API
    luaL_setglobalfunction(L, "wait_frame", lua_st_wait_frame);
    luaL_setglobalfunction(L, "frame_count", lua_st_frame_count);
    luaL_setglobalfunction(L, "time", lua_st_time);
    luaL_setglobalfunction(L, "delta_time", lua_st_delta_time);
    
    // Utility API
    luaL_setglobalfunction(L, "rgb", lua_st_rgb);
    luaL_setglobalfunction(L, "rgba", lua_st_rgba);
    luaL_setglobalfunction(L, "hsv", lua_st_hsv);
    luaL_setglobalfunction(L, "debug_print", lua_st_debug_print);
    
    // Display API
    luaL_setglobalfunction(L, "display_size", lua_st_display_size);
    luaL_setglobalfunction(L, "cell_size", lua_st_cell_size);
    
    // Error handling API
    luaL_setglobalfunction(L, "st_get_error", lua_st_get_error);
    luaL_setglobalfunction(L, "st_clear_error", lua_st_clear_error);
    
    // Key codes as constants
    luaL_setglobalnumber(L, "KEY_ESCAPE", ST_KEY_ESCAPE);
    luaL_setglobalnumber(L, "KEY_ENTER", ST_KEY_ENTER);
    luaL_setglobalnumber(L, "KEY_SPACE", ST_KEY_SPACE);
    luaL_setglobalnumber(L, "KEY_BACKSPACE", ST_KEY_BACKSPACE);
    luaL_setglobalnumber(L, "KEY_TAB", ST_KEY_TAB);
    luaL_setglobalnumber(L, "KEY_UP", ST_KEY_UP);
    luaL_setglobalnumber(L, "KEY_DOWN", ST_KEY_DOWN);
    luaL_setglobalnumber(L, "KEY_LEFT", ST_KEY_LEFT);
    luaL_setglobalnumber(L, "KEY_RIGHT", ST_KEY_RIGHT);
    
    // Letters
    luaL_setglobalnumber(L, "KEY_A", ST_KEY_A);
    luaL_setglobalnumber(L, "KEY_B", ST_KEY_B);
    luaL_setglobalnumber(L, "KEY_C", ST_KEY_C);
    luaL_setglobalnumber(L, "KEY_D", ST_KEY_D);
    luaL_setglobalnumber(L, "KEY_E", ST_KEY_E);
    luaL_setglobalnumber(L, "KEY_F", ST_KEY_F);
    luaL_setglobalnumber(L, "KEY_G", ST_KEY_G);
    luaL_setglobalnumber(L, "KEY_H", ST_KEY_H);
    luaL_setglobalnumber(L, "KEY_I", ST_KEY_I);
    luaL_setglobalnumber(L, "KEY_J", ST_KEY_J);
    luaL_setglobalnumber(L, "KEY_K", ST_KEY_K);
    luaL_setglobalnumber(L, "KEY_L", ST_KEY_L);
    luaL_setglobalnumber(L, "KEY_M", ST_KEY_M);
    luaL_setglobalnumber(L, "KEY_N", ST_KEY_N);
    luaL_setglobalnumber(L, "KEY_O", ST_KEY_O);
    luaL_setglobalnumber(L, "KEY_P", ST_KEY_P);
    luaL_setglobalnumber(L, "KEY_Q", ST_KEY_Q);
    luaL_setglobalnumber(L, "KEY_R", ST_KEY_R);
    luaL_setglobalnumber(L, "KEY_S", ST_KEY_S);
    luaL_setglobalnumber(L, "KEY_T", ST_KEY_T);
    luaL_setglobalnumber(L, "KEY_U", ST_KEY_U);
    luaL_setglobalnumber(L, "KEY_V", ST_KEY_V);
    luaL_setglobalnumber(L, "KEY_W", ST_KEY_W);
    luaL_setglobalnumber(L, "KEY_X", ST_KEY_X);
    luaL_setglobalnumber(L, "KEY_Y", ST_KEY_Y);
    luaL_setglobalnumber(L, "KEY_Z", ST_KEY_Z);
    
    // Function keys
    luaL_setglobalnumber(L, "KEY_F1", ST_KEY_F1);
    luaL_setglobalnumber(L, "KEY_F2", ST_KEY_F2);
    luaL_setglobalnumber(L, "KEY_F3", ST_KEY_F3);
    luaL_setglobalnumber(L, "KEY_F4", ST_KEY_F4);
    luaL_setglobalnumber(L, "KEY_F5", ST_KEY_F5);
    luaL_setglobalnumber(L, "KEY_F6", ST_KEY_F6);
    luaL_setglobalnumber(L, "KEY_F7", ST_KEY_F7);
    luaL_setglobalnumber(L, "KEY_F8", ST_KEY_F8);
    luaL_setglobalnumber(L, "KEY_F9", ST_KEY_F9);
    luaL_setglobalnumber(L, "KEY_F10", ST_KEY_F10);
    luaL_setglobalnumber(L, "KEY_F11", ST_KEY_F11);
    luaL_setglobalnumber(L, "KEY_F12", ST_KEY_F12);
    
    // Mouse buttons
    luaL_setglobalnumber(L, "MOUSE_LEFT", ST_MOUSE_LEFT);
    luaL_setglobalnumber(L, "MOUSE_RIGHT", ST_MOUSE_RIGHT);
    luaL_setglobalnumber(L, "MOUSE_MIDDLE", ST_MOUSE_MIDDLE);
    
    // Particle System API
    luaL_setglobalfunction(L, "st_sprite_explode", lua_st_sprite_explode);
    luaL_setglobalfunction(L, "st_sprite_explode_advanced", lua_st_sprite_explode_advanced);
    luaL_setglobalfunction(L, "st_sprite_explode_directional", lua_st_sprite_explode_directional);
    luaL_setglobalfunction(L, "st_particle_clear", lua_st_particle_clear);
    luaL_setglobalfunction(L, "st_particle_pause", lua_st_particle_pause);
    luaL_setglobalfunction(L, "st_particle_resume", lua_st_particle_resume);
    luaL_setglobalfunction(L, "st_particle_set_time_scale", lua_st_particle_set_time_scale);
    luaL_setglobalfunction(L, "st_particle_set_world_bounds", lua_st_particle_set_world_bounds);
    luaL_setglobalfunction(L, "st_particle_set_enabled", lua_st_particle_set_enabled);
    luaL_setglobalfunction(L, "st_particle_get_active_count", lua_st_particle_get_active_count);
    luaL_setglobalfunction(L, "st_particle_get_total_created", lua_st_particle_get_total_created);
    luaL_setglobalfunction(L, "st_particle_dump_stats", lua_st_particle_dump_stats);
    
    // Sprite Management API
    luaL_setglobalfunction(L, "sprite_load", lua_st_sprite_load);
    luaL_setglobalfunction(L, "sprite_load_builtin", lua_st_sprite_load_builtin);
    luaL_setglobalfunction(L, "sprite_show", lua_st_sprite_show);
    luaL_setglobalfunction(L, "sprite_hide", lua_st_sprite_hide);
    luaL_setglobalfunction(L, "sprite_transform", lua_st_sprite_transform);
    luaL_setglobalfunction(L, "sprite_tint", lua_st_sprite_tint);
    luaL_setglobalfunction(L, "sprite_unload", lua_st_sprite_unload);
    
    // Sprite-based Particle Explosion API (v1 compatible)
    luaL_setglobalfunction(L, "sprite_explode", lua_sprite_explode);
    luaL_setglobalfunction(L, "sprite_explode_advanced", lua_sprite_explode_advanced);
    luaL_setglobalfunction(L, "sprite_explode_directional", lua_sprite_explode_directional);
    luaL_setglobalfunction(L, "sprite_explode_mode", lua_sprite_explode_mode);
    
    // Explosion mode constants
    luaL_setglobalnumber(L, "BASIC_EXPLOSION", 1);
    luaL_setglobalnumber(L, "MASSIVE_BLAST", 2);
    luaL_setglobalnumber(L, "GENTLE_DISPERSAL", 3);
    luaL_setglobalnumber(L, "RIGHTWARD_BLAST", 4);
    luaL_setglobalnumber(L, "UPWARD_ERUPTION", 5);
    luaL_setglobalnumber(L, "RAPID_BURST", 6);
    
    // Particle rendering mode constants
    luaL_setglobalnumber(L, "PARTICLE_MODE_POINT_SPRITE", 0);
    luaL_setglobalnumber(L, "PARTICLE_MODE_SPRITE_FRAGMENT", 1);
    
    // Asset type constants
    luaL_setglobalnumber(L, "ASSET_IMAGE", ST_ASSET_IMAGE);
    luaL_setglobalnumber(L, "ASSET_SOUND", ST_ASSET_SOUND);
    luaL_setglobalnumber(L, "ASSET_MUSIC", ST_ASSET_MUSIC);
    luaL_setglobalnumber(L, "ASSET_FONT", ST_ASSET_FONT);
    luaL_setglobalnumber(L, "ASSET_SPRITE", ST_ASSET_SPRITE);
    luaL_setglobalnumber(L, "ASSET_DATA", ST_ASSET_DATA);
    
    // Asset Management API - Create 'asset' namespace table
    lua_newtable(L);
    
    // Initialization functions
    lua_pushcfunction(L, lua_st_asset_init);
    lua_setfield(L, -2, "init");
    
    lua_pushcfunction(L, lua_st_asset_shutdown);
    lua_setfield(L, -2, "shutdown");
    
    lua_pushcfunction(L, lua_st_asset_is_initialized);
    lua_setfield(L, -2, "isInitialized");
    
    // Loading/Unloading functions
    lua_pushcfunction(L, lua_st_asset_load);
    lua_setfield(L, -2, "load");
    
    lua_pushcfunction(L, lua_st_asset_load_file);
    lua_setfield(L, -2, "loadFile");
    
    lua_pushcfunction(L, lua_st_asset_unload);
    lua_setfield(L, -2, "unload");
    
    lua_pushcfunction(L, lua_st_asset_is_loaded);
    lua_setfield(L, -2, "isLoaded");
    
    // Import/Export functions
    lua_pushcfunction(L, lua_st_asset_import);
    lua_setfield(L, -2, "import");
    
    lua_pushcfunction(L, lua_st_asset_import_directory);
    lua_setfield(L, -2, "importDirectory");
    
    lua_pushcfunction(L, lua_st_asset_export);
    lua_setfield(L, -2, "export");
    
    lua_pushcfunction(L, lua_st_asset_delete);
    lua_setfield(L, -2, "delete");
    
    // Data access functions
    lua_pushcfunction(L, lua_st_asset_get_data);
    lua_setfield(L, -2, "getData");
    
    lua_pushcfunction(L, lua_st_asset_get_size);
    lua_setfield(L, -2, "getSize");
    
    lua_pushcfunction(L, lua_st_asset_get_type);
    lua_setfield(L, -2, "getType");
    
    lua_pushcfunction(L, lua_st_asset_get_name);
    lua_setfield(L, -2, "getName");
    
    // Query functions
    lua_pushcfunction(L, lua_st_asset_exists);
    lua_setfield(L, -2, "exists");
    
    lua_pushcfunction(L, lua_st_asset_list);
    lua_setfield(L, -2, "list");
    
    lua_pushcfunction(L, lua_st_asset_search);
    lua_setfield(L, -2, "search");
    
    lua_pushcfunction(L, lua_st_asset_get_count);
    lua_setfield(L, -2, "getCount");
    
    // Cache management functions
    lua_pushcfunction(L, lua_st_asset_clear_cache);
    lua_setfield(L, -2, "clearCache");
    
    lua_pushcfunction(L, lua_st_asset_get_cache_size);
    lua_setfield(L, -2, "getCacheSize");
    
    lua_pushcfunction(L, lua_st_asset_get_cached_count);
    lua_setfield(L, -2, "getCachedCount");
    
    lua_pushcfunction(L, lua_st_asset_set_max_cache_size);
    lua_setfield(L, -2, "setMaxCacheSize");
    
    // Statistics functions
    lua_pushcfunction(L, lua_st_asset_get_hit_rate);
    lua_setfield(L, -2, "getHitRate");
    
    lua_pushcfunction(L, lua_st_asset_get_database_size);
    lua_setfield(L, -2, "getDatabaseSize");
    
    // Error handling functions
    lua_pushcfunction(L, lua_st_asset_get_error);
    lua_setfield(L, -2, "getError");
    
    lua_pushcfunction(L, lua_st_asset_clear_error);
    lua_setfield(L, -2, "clearError");
    
    // Set the 'asset' global table
    lua_setglobal(L, "asset");
    
    // Tilemap API - Create 'tilemap' namespace table
    lua_newtable(L);
    
    // System management
    lua_pushcfunction(L, lua_st_tilemap_init);
    lua_setfield(L, -2, "init");
    
    lua_pushcfunction(L, lua_st_tilemap_shutdown);
    lua_setfield(L, -2, "shutdown");
    
    // Tilemap management
    lua_pushcfunction(L, lua_st_tilemap_create);
    lua_setfield(L, -2, "create");
    
    lua_pushcfunction(L, lua_st_tilemap_destroy);
    lua_setfield(L, -2, "destroy");
    
    lua_pushcfunction(L, lua_st_tilemap_get_size);
    lua_setfield(L, -2, "getSize");
    
    // Layer management
    lua_pushcfunction(L, lua_st_tilemap_create_layer);
    lua_setfield(L, -2, "createLayer");
    
    lua_pushcfunction(L, lua_st_tilemap_destroy_layer);
    lua_setfield(L, -2, "destroyLayer");
    
    lua_pushcfunction(L, lua_st_tilemap_layer_set_tilemap);
    lua_setfield(L, -2, "layerSetTilemap");
    
    lua_pushcfunction(L, lua_st_tilemap_layer_set_tileset);
    lua_setfield(L, -2, "layerSetTileset");
    
    lua_pushcfunction(L, lua_st_tilemap_layer_set_parallax);
    lua_setfield(L, -2, "layerSetParallax");
    
    lua_pushcfunction(L, lua_st_tilemap_layer_set_opacity);
    lua_setfield(L, -2, "layerSetOpacity");
    
    lua_pushcfunction(L, lua_st_tilemap_layer_set_visible);
    lua_setfield(L, -2, "layerSetVisible");
    
    lua_pushcfunction(L, lua_st_tilemap_layer_set_z_order);
    lua_setfield(L, -2, "layerSetZOrder");
    
    lua_pushcfunction(L, lua_st_tilemap_layer_set_auto_scroll);
    lua_setfield(L, -2, "layerSetAutoScroll");
    
    // Tile manipulation
    lua_pushcfunction(L, lua_st_tilemap_set_tile);
    lua_setfield(L, -2, "setTile");
    
    lua_pushcfunction(L, lua_st_tilemap_get_tile);
    lua_setfield(L, -2, "getTile");
    
    lua_pushcfunction(L, lua_st_tilemap_fill_rect);
    lua_setfield(L, -2, "fillRect");
    
    lua_pushcfunction(L, lua_st_tilemap_clear);
    lua_setfield(L, -2, "clear");
    
    // Camera control
    lua_pushcfunction(L, lua_st_tilemap_set_camera);
    lua_setfield(L, -2, "setCamera");
    
    lua_pushcfunction(L, lua_st_tilemap_move_camera);
    lua_setfield(L, -2, "moveCamera");
    
    lua_pushcfunction(L, lua_st_tilemap_get_camera);
    lua_setfield(L, -2, "getCamera");
    
    lua_pushcfunction(L, lua_st_tilemap_set_zoom);
    lua_setfield(L, -2, "setZoom");
    
    lua_pushcfunction(L, lua_st_tilemap_camera_follow);
    lua_setfield(L, -2, "cameraFollow");
    
    lua_pushcfunction(L, lua_st_tilemap_set_camera_bounds);
    lua_setfield(L, -2, "setCameraBounds");
    
    lua_pushcfunction(L, lua_st_tilemap_camera_shake);
    lua_setfield(L, -2, "cameraShake");
    
    // Update
    lua_pushcfunction(L, lua_st_tilemap_update);
    lua_setfield(L, -2, "update");
    
    // Coordinate conversion
    lua_pushcfunction(L, lua_st_tilemap_world_to_tile);
    lua_setfield(L, -2, "worldToTile");
    
    lua_pushcfunction(L, lua_st_tilemap_tile_to_world);
    lua_setfield(L, -2, "tileToWorld");
    
    // Tileset management
    lua_pushcfunction(L, lua_st_tileset_load);
    lua_setfield(L, -2, "loadTileset");
    
    lua_pushcfunction(L, lua_st_tileset_load_asset);
    lua_setfield(L, -2, "loadTilesetAsset");
    
    lua_pushcfunction(L, lua_st_tileset_destroy);
    lua_setfield(L, -2, "destroyTileset");
    
    lua_pushcfunction(L, lua_st_tileset_get_tile_count);
    lua_setfield(L, -2, "getTilesetTileCount");
    
    lua_pushcfunction(L, lua_st_tileset_get_dimensions);
    lua_setfield(L, -2, "getTilesetDimensions");
    
    // Set the 'tilemap' global table
    lua_setglobal(L, "tilemap");
}

} // namespace LuaBindings
} // namespace SuperTerminal